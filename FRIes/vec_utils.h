//
//  vec_utils.h
//  FRIes
//
//  Created by Samuel Greene on 7/17/19.
//  Copyright Â© 2019 Samuel Greene. All rights reserved.
//

#ifndef vec_utils_h
#define vec_utils_h

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "det_store.h"
#include "hub_holstein.h"
#include "dc.h"

/*
 Data structure used to perform addition of sparse vectors distributed across
 multiple processors.
 */
typedef struct{
    size_t size;
    long long *send_idx;
    long long *recv_idx;
    void *send_vals;
    void *recv_vals;
    int *send_cts;
    int *recv_cts;
    int *displacements;
    dtype type;
} adder;

adder *init_adder(size_t size, dtype type);

/*
 The following is a data structure for storing a sparse vector
 across many different processes.
 */
typedef struct {
    long long *indices;
    void *values;
    double *matr_el;
    size_t max_size;
    size_t curr_size;
    hash_table *vec_hash;
    stack_s *vec_stack;
    unsigned int *proc_scrambler;
    byte_table *tabl;
    unsigned int n_elec;
    unsigned char *occ_orbs;
    unsigned char *neighb;
    unsigned int n_sites;
    dtype type;
    adder *my_adder;
    int n_nonz;
} dist_vec;

dist_vec *init_vec(size_t size, size_t add_size, mt_struct *rn_ptr, unsigned int n_orb,
                   unsigned int n_elec, dtype vec_type, int n_sites);


/*
 Calculate dot product of a distributed vector with another sparse vector
 
 Parameters
 ----------
 vec: the first vector
 idx2: indices of the second vector
 vals2: values in the second vector
 num2: number of elements in the second vector
 hashes2: hash values of the indices of the second vector from the hash table
    of vec
 */
double vec_dot(dist_vec *vec, long long *idx2, double *vals2, size_t num2,
               unsigned long long *hashes2);


/* Generate array of indices of occupied orbitals from bit string
 representations of a Slater determinant, following procedure in Sec. 3.1 of
 Booth et al. (2014).
 
 Arguments
 ----------
 det: bit string to be parsed
 num_elec: number of electrons in the system (1's in the bit-string)
 table: byte table structure generated by gen_byte_table()
 occ_orbs: pointer to the array where orbitals will be stored
 
 Returns
 -------
 number of 1 bits in the bit string
 */
unsigned char gen_orb_list(long long det, byte_table *table, unsigned char *occ_orbs);

/*
 Returns the processor that is mapped to a particular index in the sparse vector
 */
int idx_to_proc(dist_vec *vec, long long idx);

/*
 Returns the hash value for the given vector index
 */
unsigned long long idx_to_hash(dist_vec *vec, long long idx);

/*
 Add element to a buffer to be added later to the vector in an MPI step
 */
void add_int(dist_vec *vec, long long idx, int val, long long ini_flag);
void add_doub(dist_vec *vec, long long idx, double val, long long ini_flag);

/* Empty the adder by adding elements to vector, following the initiator criterion
 */
void perform_add(dist_vec *vec, long long ini_bit);


// Delete an element from the vector
void del_at_pos(dist_vec *vec, size_t pos);

// Read values from the vector
int *int_at_pos(dist_vec *vec, size_t pos);
double *doub_at_pos(dist_vec *vec, size_t pos);
unsigned char *orbs_at_pos(dist_vec *vec, size_t pos);

// Vector one-norm
double local_norm(dist_vec *vec);


/* Save/load a distributed vector to/from disk, stored in binary format with file names
 [prefix]dets[proc_rank].dat and [prefix]vals[proc_rank].dat
 */
void save_vec(dist_vec *vec, const char *path);
void load_vec(dist_vec *vec, const char *path);

#endif /* vec_utils_h */
