//
//  near_uniform.h
//  FRIes
//
//  Created by Samuel Greene on 4/6/19.
//  Copyright Â© 2019 Samuel Greene. All rights reserved.
//

#ifndef near_uniform_h
#define near_uniform_h

#include <stdio.h>
#include "dc.h"
#include <math.h>

#define n_irreps 8 // number of irreps in the point group

struct s_orb_pair {
    unsigned char orb1;
    unsigned char orb2;
    unsigned char spin1;
    unsigned char spin2;
};
typedef struct s_orb_pair orb_pair;

/* Count number of unoccupied orbitals with each irrep
 */
void count_symm_virt(unsigned int counts[][2], unsigned char *occ_orbs,
                     unsigned int n_elec, unsigned int n_orb, unsigned int n_symm,
                     unsigned char (* symm_table)[n_orb + 1],
                     unsigned char *orb_irreps);

/* Execute binomial sampling with n samples, each with a probability p of
 success.
 
 Returns
 -------
 number of successes
 */
unsigned int bin_sample(unsigned int n, double p, mt_struct *rn_ptr);

/* Uniformly chooses num_sampl double excitations from a determinant
 according to the symmetry-adapted rules described in Sec. 5.2
 of Booth et al. (2014) using independent multinomial sampling.
 
 Arguments
 ---------
 det: bit string representation of the origin determinant
 occ_orbs: list of occupied orbitals in det
 num_elec: number of occupied orbitals in det
 orb_symm: irreps of the HF orbitals in the basis
 num_orb: number of unfrozen spatial orbitals in the basis
 lookup_tabl: List of orbitals with each type of symmetry, as generated by
    gen_symm_lookup()
 unocc_sym_counts: List of unoccupied orbitals with each irrep, as generated by
    count_symm_virt()
 num_sampl: number of double excitations to choose
 rn_ptr: pointer to rn generator
 chosen_orbs: array that, upon return, contains occupied (0th and 1st) and
    unoccupied orbitals for each excitation
 prob_vec: array that, upon return, contains probability for each excitation
 
 Returns
 -------
 number of non-null excitations chosen
 */
unsigned int doub_multin(long long det, unsigned char *occ_orbs, unsigned int num_elec,
                         unsigned char *orb_symm, unsigned int num_orb, unsigned char (* lookup_tabl)[num_orb + 1],
                         unsigned int (* unocc_sym_counts)[2], unsigned int num_sampl,
                         mt_struct *rn_ptr, unsigned char (* chosen_orbs)[4], double *prob_vec);

unsigned int sing_multin(long long det, unsigned char *occ_orbs, unsigned int num_elec,
                         unsigned char *orb_symm, unsigned int num_orb, unsigned char (* lookup_tabl)[num_orb + 1],
                         unsigned int (* unocc_sym_counts)[2], unsigned int num_sampl,
                         mt_struct *rn_ptr, unsigned char (* chosen_orbs)[2], double *prob_vec);

/*
 Determine the number of symmetry-allowed occupied orbitals that can be chosen
 for single excitations from a determinant.
 
 Arguments
 ---------
 occ_orbs: list of occupied orbitals in the determinant
 num_elec: number of occupied orbitals
 orb_symm: irreps of the HF orbitals in the basis
 num_orb: number of unfrozen spatial orbitals in the basis
 unocc_sym_counts: List of unoccupied orbitals with each irrep, as generated by
    count_symm_virt()
 
 Returns
 -------
 number of symmetry-allowed orbitals
 */
unsigned int count_sing_allowed(unsigned char *occ_orbs, unsigned int num_elec,
                                unsigned char *orb_symm, unsigned int num_orb,
                                unsigned int (* unocc_sym_counts)[2]);

/*
 Count the number of symmetry-allowed single excitations given the selection
 of an occupied orbital
 
 Arguments
 ---------
 occ_orbs: list of occupied orbitals in the determinant
 num_elec: number of occupied orbitals
 orb_symm: irreps of the HF orbitals in the basis
 num_orb: number of unfrozen spatial orbitals in the basis
 unocc_sym_counts: List of unoccupied orbitals with each irrep, as generated by
    count_symm_virt()
 occ_choice: pointer to index of chosen occupied orbital; upon return, contains
    orbital itself
 */
unsigned int count_sing_virt(unsigned char *occ_orbs, unsigned int num_elec,
                             unsigned char *orb_symm, unsigned int num_orb,
                             unsigned int (* unocc_sym_counts)[2],
                             unsigned char *occ_choice);

/*
 Calculate the weight of each virtual irrep pair, and the number of choices within
 each irrep pair, given a specified determinant and occupied pair
 
 Arguments
 ---------
 occ_orbs: list of occupied orbitals in the determinant
 num_elec: number of occupied orbitals
 orb_symm: irreps of the HF orbitals in the basis
 num_orb: number of unfrozen spatial orbitals in the basis
 unocc_sym_counts: List of unoccupied orbitals with each irrep, as generated by
    count_symm_virt()
 occ_choice: pointer to index of chosen occupied pair; upon return, it and the
    next array position contain the orbitals themselves
 virt_weights: upon return, contains weights of each irrep pair
 virt_counts: upon return, contains number of choices for each irrep pair
 */
void symm_pair_wt(unsigned char *occ_orbs, unsigned int num_elec,
                  unsigned char *orb_symm, unsigned int num_orb,
                  unsigned int (* unocc_sym_counts)[2], unsigned char *occ_choice,
                  double *virt_weights, unsigned char *virt_counts);


/* Perform systematic compression on full near-uniform matrix
 
 Arguments
 ---------
 dets: bit-string representations of determinants indexing the solution vector
 num_elec: number of occupied orbitals in each determinant
 occ_orbs: list of occupied orbitals in each determinant
 orb_symm: irreps of the HF orbitals in the basis
 num_orb: number of unfrozen spatial orbitals in the basis
 lookup_tabl: List of orbitals with each type of symmetry, as generated by
    gen_symm_lookup()
 unocc_sym_counts: List of unoccupied orbitals with each irrep, as generated by
    count_symm_virt()
 num_sampl: desired number of nonzero elements in matrix
 p_doub: probability of choosing a single vs double excitation
 rn_ptr: pointer to rn generator
 chosen_orbs: array that, upon return, contains indices indicating (0th) single
    or double excitation, then occupied and unoccupied orbitals for each excitation
    (must have length compress_len)
 prob_vec: array that, upon return, contains probability for each excitation
    (must have length compress_len)
 det_indices: array that, upon return, contains index of origin determinant
    for each excitation (must have length compress_len)
 scratch_vec: scratch space to use in compression (must have length num_sampl)
 compress_len: length of arrays used for compression
 Returns
 -------
 number of non-null excitations chosen
 */
//unsigned int near_uni_sys(long long dets, unsigned int num_elec, unsigned char (* occ_orbs)[num_elec],
//                          unsigned char *orb_symm, unsigned int num_orb, unsigned char (* lookup_tabl)[num_orb + 1],
//                          unsigned int (* unocc_sym_counts)[2], unsigned int num_sampl, double p_doub,
//                          mt_struct *rn_ptr, unsigned char (* chosen_orbs)[5], double *prob_vec,
//                          size_t *det_indices, double *scratch_vec, size_t compress_len);
 

#endif /* near_uniform_h */
